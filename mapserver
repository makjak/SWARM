--[[
	SWARM server by ninnghazad
	See drone-script for more info.
]]
mapserver = {}
version = "0.1"
os.loadAPI("swarm")

function locate()
	while true do
		x,y,z = gps.locate(120)
		if x ~= nil then
			break
		end
		print("Waiting for GPS-signal... "..textutils.serialize({x,y,z}))
	end
end

local function init()
	print("Booting...")
	swarm.openModem()
	locate()
	load()
	return true
end

function load()
	local mapFile = mapFile1
	local saveToggle = true
	while true do
		print("Trying backup "..mapFile.." ...")
		file = fs.open(mapFile , "r")	
		if file ~= nil then
			print("Loading "..fs.getSize(mapFile).." bytes of map data...")
			
			--[[
--			local buffer = textutils.unserialize(file.readAll())
			local buffer = ""
			for i = 1,fs.getSize(mapFile),1 do
				if i % 1024 == 0 then 
					local x,y = term.getCursorPos()
					print("Loaded: "..i.." / "..fs.getSize(mapFile))
					term.setCursorPos(x,y)
					sleep(0) 
				end
				buffer = buffer..file.read()
			end
			sleep(0)
			buffer = textutils.unserialize(buffer)
			--]]
			
			local buffer = file.readAll()
			file.close()
			sleep(0)--
			buffer = textutils.unserialize(buffer)
			if not buffer then 
				print("Saved data corrupt, could not deserialize.")
				worldMap = nil
			else
				print("Recreating map from saved data...")
				worldMap = map.new(0,buffer)
			end
			
			if worldMap ~= nil and type(worldMap) == "table" then print("Successfully loaded.") break end
		else
			print("There is no such map data: '"..mapFile.."'")
		end
		if saveToggle then
			saveToggle = false
			mapFile = mapFile2
		else
			print("Could not load any saved map!")
			worldMap = map.new()
			sleep(10)
			break
		end
		print("failed 2")
		sleep(4)
	end
end

function net()
	callDepth = 0
	swarm.status(callDepth,"mapserver is now running")
	local e,coord,msg,stink,id
	stink = 1
	while true do
		e = {os.pullEvent("modem_message")}
		id = e[4]
		msg = e[5]["message"]

		if msg:byte(1) == 10 then -- position broadcast from drone, remember those
			coord = textutils.unserialize(string.sub(msg,2))
			if coord ~= nil and type(coord) == "table" and #coord >= 3 then
				dronePositions[id] = {coord,swarm.timestamp()}
				
				worldMap:set(coord[1],coord[2],coord[3],{0,1})
			else
				errors[#errors+1] = "received corrupt position broadcast from "..id.." "..textutils.serialize(coord)
			end
			counter[4] = counter[4] + 1
		elseif msg:byte(1) == 1 then -- worldMap get request
			--local start = os.clock()
			coord = textutils.unserialize(string.sub(msg,2))
			if coord ~= nil and type(coord) == "table" then
				msg = string.char(2).." "..textutils.serialize(worldMap:get(coord[1],coord[2],coord[3]))
				rednet.send(id,msg)
				--errors[0] = id.." "..msg
			else
				errors[#errors+1] = "received corrupt get request from "..id
			end
			counter[1] = counter[1] + 1
			--swarm.log("get request took "..(os.clock()-start)) -- takes 0
		elseif msg:byte(1) == 3 then -- worldMap set request
			counter[2] = counter[2] + 1
			coord = textutils.unserialize(string.sub(msg,2))
			if coord ~= nil then
				if coord[4] == nil then
					worldMap:set(coord[1],coord[2],coord[3],nil)
				else
					--[[stink = worldMap:get(coord[1],coord[2],coord[3])
					if stink == nil then
						stink = 1
					else 
						stink = stink[2] + 1
					end]]
					
					worldMap:set(coord[1],coord[2],coord[3],{coord[4],stink})
				end
			else
				errors[#errors+1] = "received corrupt set request from "..e[2]
			end
		elseif msg:byte(1) == 100 then -- Status query 
			rednet.send(id,string.char(101).."MAPSERVER "..id.." ")
		elseif msg:byte(1) == 110 then -- Reboot signal
			swarm.status(callDepth,"received reboot signal")
			save()
			rednet.send(id,string.char(111))
			
			swarm.status(callDepth,"will now reboot")
			os.reboot()
			break
		elseif msg:byte(1) == 130 then -- Hard reboot signal
			os.reboot()
			break
		elseif msg:byte(1) == 140 then -- Shutdown signal
			swarm.status(callDepth,"received shutdown signal")
			save()
			rednet.send(id,string.char(141))
			swarm.status(callDepth,"will now shutdown")
			os.shutdown()
			break
		elseif msg:byte(1) == 120 then -- Full status query
			rednet.send(id,string.char(121)..textutils.serialize(swarm._status))
		elseif msg == "PING" or msg == "ping" or msg:byte(1) == 123 then -- Serve PING/GPS request
			counter[3] = counter[3] + 1
			rednet.send(id,textutils.serialize({x,y,z}))
		--	errors[#errors+1] = "gps to "..id
		end
	end
	errors[#errors+1] = "listener exits!"
end

function key()
	local e
	while true do
		e = {os.pullEvent("key")}
		if e[2] == 16 then -- Q
			print("Q pressed, quitting...")
			--print(""..nil)
			break
		elseif e[2] == 50 then
			mode = "map"
		elseif e[2] == 31 then
			mode = "status"
		elseif e[2] == 78 then
			viewPos[3] = viewPos[3] + 1
		elseif e[2] == 74 then
			viewPos[3] = viewPos[3] - 1
		elseif e[2] == 200 then
			viewPos[2] = viewPos[2] - 1
		elseif e[2] == 208 then
			viewPos[2] = viewPos[2] + 1
		elseif e[2] == 203 then
			viewPos[1] = viewPos[1] - 1
		elseif e[2] == 205 then
			viewPos[1] = viewPos[1] + 1
		end
	end
end

function save()
	local timer = os.startTimer(saveInterval)
	local e,data,file,start
	local mapFile = mapFile1
	local saveToggle = true

	while true do
		e = {os.pullEvent("timer")}
		if e[2] == timer then
			start = swarm.timestamp()
			if saveToggle then
				saveToggle = false
				mapFile = mapFile1
			else
				saveToggle = true
				mapFile = mapFile2
			end
			
				--[[errors[1] = "serializing world in background ..."
				data = textutils.serializeMap(worldMap)
				errors[1] = "serialized, now writing ..."
				
				if data == nil then
					errors[#errors+1] = "Could not serialize data for saving."
				else]]
			file = fs.open(mapFile, "w")
			
			if file ~= nil then
			--[[	local i = 0
				file.write("{")
				for x,xv in pairs(worldMap) do
					file.write("["..x.."]={")
					for y,yv in pairs(xv) do
						file.write("["..y.."]={")
						for z,v in pairs(yv) do
							i= i+1
							if i % 1000 == 0 then sleep(0) end
							errors[1] = "saving world "..x..","..y..","..z.." #"..i
							file.write("["..z.."]="..textutils.serialize(v)..",")
							--sleep(0) -- ugly yield, no other events but timer, so it should be ok
						end
						file.write("},")
					end
					file.write("},")
				end
				file.write("} ")
				]]
				local buffer = textutils.serialize(worldMap)
				file.write(buffer)
				sleep(0)
				
				file.close()	
				buffer = #buffer
				--errors[1] = "saved world with "..i.." entries at "..swarm.timestamp().." in "..((swarm.timestamp()-start)/20).." seconds to "..mapFile1
				errors[1] = "saved world with "..buffer.." bytes at "..swarm.timestamp().." in "..((swarm.timestamp()-start)/20).." seconds to "..mapFile
			else
				errors[#errors+1] = "Could not open file '"..mapFile.."' for writing."
			end
			
			
			
				

			
			data = nil
			e = nil
			sleep(0)
			
			if saveToggle then
				if fs.exists(mapFile1) then fs.delete(mapFile1) end
			else
				if fs.exists(mapFile2) then fs.delete(mapFile2) end
			end
			
			--sleep(100)
			timer = os.startTimer(saveInterval)
			
		end
		
	end
	
end


function gui()
	local activity = {"Ooo","oOo","ooO","oOo"}
	local activityCounter = 1
	local startTime = swarm.timestamp()
	local timer = os.startTimer(statusInterval)
	local k,v,e,msg
	while true do
		sleep(statusInterval);
		--e = {os.pullEvent("timer")}
		--if e[2] == timer then
			
			if mode == "status" then -- Display numeric status infos
				term.clear()
				--term.clearLine()
				term.setCursorPos(1,1)
				msg = "~( *> SWARM mapserver <* )~ ["..activity[activityCounter].."]\n"
				msg = msg.."[up: "..swarm.formatTime(os.clock()).."]\n"
				msg = msg.."[run: "..swarm.formatTime((swarm.timestamp()-startTime)/20).."]".."\n"
				activityCounter = activityCounter + 1
				if activityCounter > #activity then activityCounter = 1 end
				msg = msg.."get requests served: "..counter[1].."\n"
				msg = msg.."set requests served: "..counter[2].."\n"
				msg = msg.."area requests served: "..counter[5].."\n"
				msg = msg.."path get requests served: "..counter[6].."\n"
				msg = msg.."path set requests served: "..counter[7].."\n"
				msg = msg.."gps requests served: "..counter[3].."\n"
				msg = msg.."position broadcasts: "..counter[4].."\n"
				--[[msg = msg.."drones: ".."\n"
				--local now = swarm.timestamp()
				for k,v in pairs(dronePositions) do
					msg = msg..k..": "..textutils.serialize(v).."\n"
					--print(k..": "..v[1][1]..","..v[1][2]..","..v[1][3].." "..v[1][4].."["..(now-v[2]).." s ago.]")
				end
				msg = msg.."\n"
				]]--
				msg = msg.."errors:\n"
				for k,v in pairs(errors) do
					msg = msg..k..": "..v.."\n"
				end
				--swarm.log(msg)
				print(msg)
			--[[elseif mode == "map" then -- Display graphic map, ooh, the oldskool-goodness...
				local x,y,z,v,tx,ty
				term.clear()
				term.setCursorPos(1,1)
				screenMap = {}
				for y=1,screenSize[2],1 do
					ty = (viewPos[2] - (screenSize[2]/2)) + y
					for x=1,screenSize[1],1 do
						tx = (viewPos[1] - (screenSize[1]/2)) + x
							v = worldMap:get(tx,ty,viewPos[3])
							if v == nil then
								v = "#"
							elseif v[1] == 0 then
								v = "."
							else
								v = "X"
							end
						--end
						if screenMap[y] == nil then
							screenMap[y] = v
						else
							screenMap[y] = screenMap[y]..v
						end
					end
				end
				
				-- Draw generated map on screen
				term.setCursorPos(1,2)
				for y=1,screenSize[2],1 do
					term.write(screenMap[y])
					if y < screenSize[2] then
						print()
					end
				end
				
				-- Overlay drone positions
				for k,v in pairs(dronePositions) do
					if v[1][3] == viewPos[3] then
						x = v[1][1] - (viewPos[1] - (screenSize[1]/2))
						y = v[1][2] - (viewPos[2] - (screenSize[2]/2))
						if not (x < 0 or y < 0 or x > screenSize[1] or y > screenSize[2]) then
							term.setCursorPos(x,y)
							term.setTextColor(16384)
							term.write("@")
						end
						
					end
				end
				
				-- Overlay current viewPos
				term.setCursorPos(1,1)
				term.setTextColor(16384)
				term.write("["..viewPos[1].."]["..viewPos[2].."]["..viewPos[3].."]")
				term.setTextColor(1)
				]]
			end
						
		--	timer = os.startTimer(statusInterval)
		--end
	end
end


os.loadAPI("swarm")	
swarm.debug.override()


function run()
	swarm.gpsPos = {6,6,6}
	local startTime = swarm.timestamp()
	
	term.clear()
	term.setCursorPos(1,1)

	worldMap = map.new(0)
	mapFile1 = "worldMap.data.0."..os.getComputerID() 
	mapFile2 =  "worldMap.data.1."..os.getComputerID() 
	name = os.getComputerLabel()
	id = os.getComputerID()
	dronePositions = {}
	counter = {0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	saveInterval = 3600 -- once an hour
	statusInterval = 0.5
	--local viewPos = {283,-300,84}
	screenSize = {term.getSize()}
	mode = "status" -- If this is == status, diplay numeric infos, if it is == map, diplay graphical map
	--local screenMap = {}
	errors = {}

	init()

	sleep(4)

	term.clear()
	term.setCursorPos(1,1)


	print("Waiting for signals(press Q to quit,press M or S toggle mode) ...")

	function wrapReceiver() return swarm.wrap(net,"network receiver") end 
	function wrapWriter() return swarm.wrap(save,"data writer") end 
	function wrapGui() return swarm.wrap(gui,"gui") end 
	function wrapKeyboard() return swarm.wrap(key,"keyboard handler") end 
		
	parallel.waitForAny(wrapReceiver,wrapWriter,wrapGui,wrapKeyboard)

	print("shutting down...")
	--sleep(7200*10)
	print(textutils.serialize(errors))
end
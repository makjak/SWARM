--[[
	SWARM server by ninnghazad
	See drone-script for more info.
]]
mapserver = {}
version = "0.1"
os.loadAPI("swarm")
swarm.setSystemType("mapserver")

function locate()
	while true do
		x,y,z = gps.locate(120)
		if x ~= nil then
			break
		end
		print("Waiting for GPS-signal... "..textutils.serialize({x,y,z}))
	end
end

local function init()
	print("Booting...")
	swarm.openModem()
	locate()
	load()
	return true
end

function load()
	local mapFile = mapFile1
	local saveToggle = true
	while true do
		print("Trying backup "..mapFile.." ...")
		file = fs.open(mapFile , "r")	
		if file ~= nil then
			print("Loading "..fs.getSize(mapFile).." bytes of map data...")
			
			--[[
--			local buffer = textutils.unserialize(file.readAll())
			local buffer = ""
			for i = 1,fs.getSize(mapFile),1 do
				if i % 1024 == 0 then 
					local x,y = term.getCursorPos()
					print("Loaded: "..i.." / "..fs.getSize(mapFile))
					term.setCursorPos(x,y)
					sleep(0) 
				end
				buffer = buffer..file.read()
			end
			sleep(0)
			buffer = textutils.unserialize(buffer)
			--]]
			
			local buffer = file.readAll()
			file.close()
			sleep(0)--
			buffer = textutils.unserialize(buffer)
			if not buffer then 
				print("Saved data corrupt, could not deserialize.")
				worldMap = nil
			else
				print("Recreating map from saved data...")
				worldMap = map.new(0,buffer)
			end
			
			if worldMap ~= nil and type(worldMap) == "table" then print("Successfully loaded.") break end
		else
			print("There is no such map data: '"..mapFile.."'")
		end
		if saveToggle then
			saveToggle = false
			mapFile = mapFile2
		else
			print("Could not load any saved map!")
			worldMap = map.new()
			sleep(10)
			break
		end
		print("failed 2")
		sleep(4)
	end
end

function net()
	callDepth = 0
	swarm.status(callDepth,"mapserver is now running")
	local e,coord,msg,stink,id
	stink = 1
	while true do
		e = {os.pullEvent("modem_message")}
		id = e[4]
		msg = e[5]["message"]

		if msg:byte(1) == 10 then -- position broadcast from drone, remember those
			coord = textutils.unserialize(string.sub(msg,2))
			if coord ~= nil and type(coord) == "table" and #coord >= 3 then
				dronePositions[id] = {coord,swarm.timestamp()}
				
				worldMap:set(coord[1],coord[2],coord[3],{0,1})
			else
				errors[#errors+1] = "received corrupt position broadcast from "..id.." "..textutils.serialize(coord)
			end
			swarm.statistics["Drone Broadcasts"] = swarm.statistics["Drone Broadcasts"] + 1
		elseif msg:byte(1) == 1 then -- worldMap get request
			--local start = os.clock()
			coord = textutils.unserialize(string.sub(msg,2))
			if coord ~= nil and type(coord) == "table" then
				msg = string.char(2).." "..textutils.serialize(worldMap:get(coord[1],coord[2],coord[3]))
				rednet.send(id,msg)
				--errors[0] = id.." "..msg
			else
				errors[#errors+1] = "received corrupt get request from "..id
			end
			swarm.statistics["GET"] = swarm.statistics["GET"] + 1
			--swarm.log("get request took "..(os.clock()-start)) -- takes 0
		elseif msg:byte(1) == 3 then -- worldMap set request
			swarm.statistics["SET"] = swarm.statistics["SET"] + 1
			coord = textutils.unserialize(string.sub(msg,2))
			if coord ~= nil then
				if coord[4] == nil then
					worldMap:set(coord[1],coord[2],coord[3],nil)
				else
					--[[stink = worldMap:get(coord[1],coord[2],coord[3])
					if stink == nil then
						stink = 1
					else 
						stink = stink[2] + 1
					end]]
					
					worldMap:set(coord[1],coord[2],coord[3],{coord[4],stink})
				end
			else
				errors[#errors+1] = "received corrupt set request from "..e[2]
			end
		elseif msg:byte(1) == 100 then -- Status query 
			rednet.send(id,string.char(101).."MAPSERVER "..id.." ")
		elseif msg:byte(1) == 110 then -- Reboot signal
			swarm.status(callDepth,"received reboot signal")
		--	save()
			rednet.send(id,string.char(111))
			
			swarm.status(callDepth,"will now reboot")
			os.reboot()
			break
		elseif msg:byte(1) == 130 then -- Hard reboot signal
			os.reboot()
			break
		elseif msg:byte(1) == 140 then -- Shutdown signal
			swarm.status(callDepth,"received shutdown signal")
		--	save()
			rednet.send(id,string.char(141))
			swarm.status(callDepth,"will now shutdown")
			os.shutdown()
			break
		elseif msg:byte(1) == 120 then -- Full status query
			rednet.send(id,string.char(121)..textutils.serialize(swarm._status))
		elseif msg == "PING" or msg == "ping" or msg:byte(1) == 123 then -- Serve PING/GPS request
			swarm.statistics["GPS"] = swarm.statistics["GPS"] + 1
			rednet.send(id,textutils.serialize({x,y,z}))
		--	errors[#errors+1] = "gps to "..id
		end
	end
	errors[#errors+1] = "listener exits!"
end

function key()
	local e
	while true do
		e = {os.pullEvent("key")}
		if e[2] == 16 then -- Q
			print("Q pressed, quitting...")
			--print(""..nil)
			break
		elseif e[2] == 50 then
			mode = "map"
		elseif e[2] == 31 then
			mode = "status"
		elseif e[2] == 78 then
			viewPos[3] = viewPos[3] + 1
		elseif e[2] == 74 then
			viewPos[3] = viewPos[3] - 1
		elseif e[2] == 200 then
			viewPos[2] = viewPos[2] - 1
		elseif e[2] == 208 then
			viewPos[2] = viewPos[2] + 1
		elseif e[2] == 203 then
			viewPos[1] = viewPos[1] - 1
		elseif e[2] == 205 then
			viewPos[1] = viewPos[1] + 1
		end
	end
end

function save()
	local timer = os.startTimer(saveInterval)
	local e,data,file,start
	local mapFile = mapFile1
	local saveToggle = true

	while true do
		e = {os.pullEvent("timer")}
		if e[2] == timer then
			start = swarm.timestamp()
			if saveToggle then
				saveToggle = false
				mapFile = mapFile1
			else
				saveToggle = true
				mapFile = mapFile2
			end
			
				--[[errors[1] = "serializing world in background ..."
				data = textutils.serializeMap(worldMap)
				errors[1] = "serialized, now writing ..."
				
				if data == nil then
					errors[#errors+1] = "Could not serialize data for saving."
				else]]
			file = fs.open(mapFile, "w")
			
			if file ~= nil then
			--[[	local i = 0
				file.write("{")
				for x,xv in pairs(worldMap) do
					file.write("["..x.."]={")
					for y,yv in pairs(xv) do
						file.write("["..y.."]={")
						for z,v in pairs(yv) do
							i= i+1
							if i % 1000 == 0 then sleep(0) end
							errors[1] = "saving world "..x..","..y..","..z.." #"..i
							file.write("["..z.."]="..textutils.serialize(v)..",")
							--sleep(0) -- ugly yield, no other events but timer, so it should be ok
						end
						file.write("},")
					end
					file.write("},")
				end
				file.write("} ")
				]]
				local buffer = textutils.serialize(worldMap)
				file.write(buffer)
				sleep(0)
				
				file.close()	
				buffer = #buffer
				--errors[1] = "saved world with "..i.." entries at "..swarm.timestamp().." in "..((swarm.timestamp()-start)/20).." seconds to "..mapFile1
				errors[1] = "saved world with "..buffer.." bytes at "..swarm.timestamp().." in "..((swarm.timestamp()-start)/20).." seconds to "..mapFile
			else
				errors[#errors+1] = "Could not open file '"..mapFile.."' for writing."
			end
			
			
			
				

			
			data = nil
			e = nil
			sleep(0)
			
			if saveToggle then
				if fs.exists(mapFile1) then fs.delete(mapFile1) end
			else
				if fs.exists(mapFile2) then fs.delete(mapFile2) end
			end
			
			--sleep(100)
			timer = os.startTimer(saveInterval)
			
		end
		
	end
	
end





function run()
	swarm.gpsPos = {6,6,6}
	local startTime = swarm.timestamp()
	
	term.clear()
	term.setCursorPos(1,1)

	worldMap = map.new(0)
	mapFile1 = "worldMap.data.0."..os.getComputerID() 
	mapFile2 =  "worldMap.data.1."..os.getComputerID() 
	name = os.getComputerLabel()
	id = os.getComputerID()
	dronePositions = {}

	swarm.statistics["GET"] = 0
	swarm.statistics["SET"] = 0
	swarm.statistics["GET Area"] = 0
	swarm.statistics["GET Path"] = 0
	swarm.statistics["SET Path"] = 0
	swarm.statistics["GPS"] = 0
	swarm.statistics["Drone Broadcasts"] = 0
	
	saveInterval = 3600 -- once an hour
	statusInterval = 0.5
	--local viewPos = {283,-300,84}
	screenSize = {term.getSize()}
	mode = "status" -- If this is == status, diplay numeric infos, if it is == map, diplay graphical map
	--local screenMap = {}
	errors = {}

	init()

	sleep(4)

	term.clear()
	term.setCursorPos(1,1)


	print("Waiting for signals(press Q to quit,press M or S toggle mode) ...")

	function wrapReceiver() return swarm.wrap(net,"network receiver") end 
	function wrapWriter() return swarm.wrap(save,"data writer") end 
	function wrapKeyboard() return swarm.wrap(key,"keyboard handler") end 
		
	parallel.waitForAny(wrapReceiver,wrapWriter,swarm.wrapGui,wrapKeyboard)

	print("shutting down...")
	--sleep(7200*10)
	print(textutils.serialize(errors))
end